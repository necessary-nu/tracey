<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  <title>tracey</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNiIgZmlsbD0iIzFhMWIyNiIvPjxwYXRoIGQ9Ik04IDI0IEwxNCA4IEwxOCAxNiBMMjQgOCIgc3Ryb2tlPSIjN2FhMmY3IiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0ibm9uZSIvPjxjaXJjbGUgY3g9IjgiIGN5PSIyNCIgcj0iMi41IiBmaWxsPSIjNzNkYWNhIi8+PGNpcmNsZSBjeD0iMjQiIGN5PSI4IiByPSIyLjUiIGZpbGw9IiM3M2RhY2EiLz48L3N2Zz4=">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;1,400&family=Public+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <script type="importmap">
  {
    "imports": {
      "preact": "https://esm.sh/preact@10.25.4",
      "preact/hooks": "https://esm.sh/preact@10.25.4/hooks",
      "htm": "https://esm.sh/htm@3.1.1",
      "marked": "https://esm.sh/marked@15.0.6",
      "@arborium/arborium": "https://esm.sh/@arborium/arborium"
    }
  }
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@arborium/arborium@2.4.6/dist/themes/base.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@arborium/arborium@2.4.6/dist/themes/tokyo-night.css">
  <style>
    :root {
      color-scheme: light dark;
      --bg: light-dark(#f8f9fa, #13141a);
      --bg-secondary: light-dark(#ffffff, #1a1b26);
      --bg-sidebar: light-dark(#f3f4f6, #16171d);
      --fg: light-dark(#1a1b26, #c0caf5);
      --fg-muted: light-dark(#6b7280, #737aa2);
      --fg-dim: light-dark(#9ca3af, #565f89);
      --border: light-dark(#e5e5e5, #292e42);
      --hover: light-dark(#f0f0f2, #1f2335);
      --hover-subtle: light-dark(#f8f8fa, #1a1d2a);
      --accent: light-dark(#2563eb, #7aa2f7);
      --accent-dim: light-dark(#dbeafe, #1e3a5f);
      --green: light-dark(#16a34a, #73daca);
      --green-dim: light-dark(#dcfce7, #1a2e2a);
      --red: light-dark(#dc2626, #f7768e);
      --red-dim: light-dark(#fee2e2, #2d1f1f);
      --yellow: light-dark(#d97706, #e0af68);
      --yellow-dim: light-dark(#fef3c7, #3d3520);
      --purple: light-dark(#7c3aed, #bb9af7);
      --bg-outer: light-dark(#e5e7eb, #0d0e12);
      
      --max-width: 1200px;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Public Sans', system-ui, -apple-system, sans-serif;
      background: var(--bg-outer);
      color: var(--fg);
      line-height: 1.5;
    }
    
    #app { min-height: 100vh; display: flex; flex-direction: column; }
    
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      color: var(--fg-muted);
      font-size: 0.9rem;
    }
    
    /* Layout */
    .layout {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: var(--max-width);
      max-width: 100%;
      margin: 0 auto;
      background: var(--bg);
      border-left: 1px solid var(--border);
      border-right: 1px solid var(--border);
    }
    
    .header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      position: relative;
      z-index: 100;
    }
    
    .header-inner {
      display: flex;
      align-items: stretch;
      width: 100%;
      margin-bottom: -1px; /* tabs overlap the border */
    }
    
    .logo {
      font-weight: 600;
      font-size: 1.1rem;
      color: var(--fg);
      text-decoration: none;
      display: flex;
      align-items: center;
      padding: 0.75rem 1.25rem;
      margin-left: auto;
    }
    
    .logo:hover {
      background: var(--hover-subtle);
    }
    
    .nav {
      display: flex;
    }
    
    .nav-tab {
      padding: 0.75rem 1.25rem;
      background: transparent;
      color: var(--fg-muted);
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      font-size: 0.9rem;
      font-family: inherit;
      transition: all 0.15s;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .nav-tab:hover {
      background: var(--hover-subtle);
      color: var(--fg);
    }
    
    .nav-tab.active {
      color: var(--accent);
      border-bottom: 2px solid var(--accent);
      background: var(--bg);
    }
    
    .tab-icon {
      width: 1rem;
      height: 1rem;
    }
    
    .search-box {
      flex: 1;
      max-width: 400px;
      margin-left: auto;
    }
    
    .search-input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      background: var(--bg);
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 0.85rem;
      font-family: inherit;
    }
    
    .search-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-dim);
    }
    
    .search-input::placeholder {
      color: var(--fg-dim);
    }
    
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
      width: 100%;
    }
    
    /* Stats bar */
    .stats-bar {
      display: flex;
      align-items: center;
      gap: 2rem;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      width: 100%;
      position: relative;
      z-index: 50;
    }
    
    .stat {
      display: flex;
      flex-direction: column;
      gap: 0.125rem;
    }
    
    .stat-label {
      font-size: 0.75rem;
      color: var(--fg-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      font-family: 'IBM Plex Mono', monospace;
    }
    
    .stat-value.good { color: var(--green); }
    .stat-value.warn { color: var(--yellow); }
    .stat-value.bad { color: var(--red); }
    
    .stat.clickable {
      cursor: pointer;
      padding: 0.5rem;
      margin: -0.5rem;
      border-radius: 6px;
      transition: background 0.15s;
    }
    
    .stat.clickable:hover {
      background: var(--hover);
    }
    
    .stats-controls {
      display: flex;
      gap: 0.75rem;
      margin-left: auto;
    }
    
    /* Sidebar */
    .sidebar {
      width: 280px;
      border-right: 1px solid var(--border);
      background: var(--bg-sidebar);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .sidebar-header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      font-weight: 500;
      font-size: 0.85rem;
      color: var(--fg-muted);
    }
    
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
    }
    
    /* File tree */
    .file-tree {
      padding: 0.5rem;
    }
    
    .tree-folder {
      user-select: none;
    }
    
    .tree-folder-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--fg);
    }
    
    .tree-folder-header:hover {
      background: var(--hover);
    }
    
    .tree-folder-left {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    
    .tree-folder-icon {
      width: 1rem;
      height: 1rem;
      color: var(--fg-dim);
      transition: transform 0.15s;
    }
    
    .tree-folder.open > .tree-folder-header .tree-folder-icon {
      transform: rotate(90deg);
    }
    
    .folder-badge {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
      font-weight: 500;
    }
    .folder-badge.full { background: var(--green-dim); color: var(--green); }
    .folder-badge.partial { background: var(--yellow-dim); color: var(--yellow); }
    .folder-badge.none { background: var(--red-dim); color: var(--red); }
    
    .tree-folder-children {
      display: none;
      padding-left: 1rem;
    }
    
    .tree-folder.open > .tree-folder-children {
      display: block;
    }
    
    .tree-file {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.35rem 0.5rem;
      padding-left: calc(0.5rem + 1rem + 0.25rem); /* match folder: padding + icon width + gap */
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
    }
    
    .tree-file:hover {
      background: var(--hover);
    }
    
    .tree-file.selected {
      background: var(--accent-dim);
      color: var(--accent);
    }
    
    .tree-file-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .tree-file-badge {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
      font-weight: 500;
    }
    
    .tree-file-badge.full { background: var(--green-dim); color: var(--green); }
    .tree-file-badge.partial { background: var(--yellow-dim); color: var(--yellow); }
    .tree-file-badge.none { background: var(--red-dim); color: var(--red); }
    
    /* Content area */
    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--bg);
    }
    
    .content-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.5rem 1rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
    }
    
    .content-body {
      flex: 1;
      overflow: auto;
    }
    
    /* Code view */
    .code-view {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      line-height: 1.6;
    }
    
    .code-line {
      display: flex;
      min-height: 1.5em;
    }
    
    .code-line:hover {
      background: var(--hover-subtle);
    }
    
    .code-line.highlighted {
      background: var(--yellow-dim);
    }
    
    .line-number {
      width: 4rem;
      padding: 0 0.75rem 0 0.5rem;
      text-align: right;
      color: var(--fg-dim);
      user-select: none;
      flex-shrink: 0;
      cursor: pointer;
      position: relative;
      border-left: 3px solid transparent;
    }
    
    .code-line.covered .line-number {
      border-left-color: var(--green);
    }
    
    .code-line.uncovered .line-number {
      border-left-color: var(--red);
    }
    
    .line-number:hover {
      color: var(--accent);
    }
    
    .line-popover {
      position: absolute;
      left: 100%;
      top: 50%;
      transform: translateY(-50%);
      margin-left: 0.5rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      white-space: nowrap;
    }
    
    .popover-btn {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      color: var(--fg);
      text-decoration: none;
      font-size: 0.8rem;
    }
    
    .popover-btn:hover {
      background: var(--hover);
    }
    
    .popover-btn svg {
      width: 1rem;
      height: 1rem;
    }
    
    .line-content {
      flex: 1;
      padding-right: 1rem;
      white-space: pre;
    }
    
    .line-annotations {
      padding: 0 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      position: relative;
    }
    
    .annotation-count {
      font-size: 0.6rem;
      min-width: 1.2em;
      height: 1.2em;
      padding: 0 0.25rem;
      border-radius: 3px;
      background: var(--accent-dim);
      color: var(--accent);
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    .annotation-badges {
      display: none;
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.25rem;
      gap: 0.25rem;
      flex-wrap: wrap;
      max-width: 300px;
      z-index: 50;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .line-annotations:hover .annotation-badges {
      display: flex;
    }
    
    .line-annotations:hover .annotation-count {
      display: none;
    }
    
    .annotation-badge {
      font-size: 0.65rem;
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      background: var(--accent-dim);
      color: var(--accent);
      font-weight: 500;
      white-space: nowrap;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    a.annotation-badge:hover {
      background: var(--accent);
      color: white;
    }
    
    /* Rules table */
    .rules-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .rules-table th {
      text-align: left;
      padding: 0.75rem 1rem;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--fg-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    .rules-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      vertical-align: top;
    }
    
    .rules-table tr:hover td {
      background: var(--hover-subtle);
    }
    
    .rule-id {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--accent);
    }
    
    .rule-text {
      font-size: 0.85rem;
      color: var(--fg-muted);
      margin-top: 0.25rem;
    }
    
    .rule-text code {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 90%;
      background: var(--hover);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
    }
    
    .rule-refs {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.8rem;
    }
    
    .rule-ref {
      display: block;
      color: var(--fg-muted);
      text-decoration: none;
      padding: 0.125rem 0;
    }
    
    .rule-ref:hover {
      color: var(--accent);
    }
    
    .rule-ref.impl { color: var(--green); }
    .rule-ref.verify { color: var(--accent); }
    
    /* Split view */
    .split-view {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .split-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-width: 0;
    }
    
    .split-pane + .split-pane {
      border-left: 1px solid var(--border);
    }
    
    .split-pane-header {
      padding: 0.5rem 1rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      font-size: 0.85rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .split-pane-content {
      flex: 1;
      overflow: auto;
    }
    
    /* Markdown content */
    .markdown {
      padding: 0.75rem 2rem 1.5rem 2rem;
      font-size: 0.9rem;
      line-height: 1.7;
    }
    
    .markdown h1, .markdown h2, .markdown h3, .markdown h4 {
      margin: 1.5rem 0 0.75rem;
      font-weight: 600;
      color: var(--fg);
      cursor: pointer;
    }
    
    .markdown h1:hover, .markdown h2:hover, .markdown h3:hover, .markdown h4:hover {
      color: var(--accent);
    }
    
    .markdown h1 { font-size: 1.5rem; }
    .markdown h2 { font-size: 1.25rem; }
    .markdown h3 { font-size: 1.1rem; }
    
    .markdown p {
      margin: 0.75rem 0;
    }
    
    .markdown code {
      font-family: 'IBM Plex Mono', monospace;
      background: var(--hover);
      padding: 0.15rem 0.35rem;
      border-radius: 4px;
      font-size: 0.85em;
    }
    
    .markdown pre {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 1rem;
      overflow-x: auto;
      margin: 1rem 0;
    }
    
    .markdown pre code {
      background: none;
      padding: 0;
    }
    
    .markdown ul, .markdown ol {
      margin: 0.75rem 0;
      padding-left: 1.5rem;
    }
    
    .markdown li {
      margin: 0.25rem 0;
    }
    
    .markdown blockquote {
      border-left: 3px solid var(--accent);
      margin: 1rem 0;
      padding-left: 1rem;
      color: var(--fg-muted);
    }
    
    /* RFC 2119 keyword highlighting */
    kw-must, kw-must-not, kw-required, kw-shall, kw-shall-not {
      color: var(--red);
      font-weight: 600;
    }
    kw-should, kw-should-not, kw-recommended, kw-not-recommended {
      color: var(--yellow);
      font-weight: 600;
    }
    kw-may, kw-optional {
      color: var(--accent);
      font-weight: 600;
    }
    
    /* Rule marker in spec */
    .rule-marker {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      width: fit-content;
      background: var(--accent-dim);
      color: var(--accent);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      margin: 0.15rem 0;
      text-decoration: none;
    }
    
    a.rule-marker:hover {
      filter: brightness(1.1);
    }
    
    .rule-marker-icon {
      width: 0.9em;
      height: 0.9em;
      flex-shrink: 0;
    }
    
    .rule-marker.covered {
      background: var(--green-dim);
      color: var(--green);
    }
    
    .rule-marker.partial {
      background: var(--yellow-dim);
      color: var(--yellow);
    }
    
    .rule-marker.uncovered {
      background: var(--red-dim);
      color: var(--red);
    }
    
    .rule-marker-highlighted {
      animation: rule-highlight-pulse 3s ease-out;
    }
    
    @keyframes rule-highlight-pulse {
      0%, 20% {
        box-shadow: 0 0 0 4px var(--accent);
        transform: scale(1.05);
      }
      100% {
        box-shadow: 0 0 0 0 transparent;
        transform: scale(1);
      }
    }
    
    /* Rule block - fieldset-like container */
    .rule-block {
      position: relative;
      border: 1px solid var(--border);
      border-radius: 6px;
      margin: 1rem 0;
      padding: 0.75rem 1rem 0.75rem 1rem;
    }
    
    .rule-block-covered { border-color: color-mix(in srgb, var(--green) 40%, var(--border)); }
    .rule-block-partial { border-color: color-mix(in srgb, var(--yellow) 40%, var(--border)); }
    .rule-block-uncovered { border-color: color-mix(in srgb, var(--red) 40%, var(--border)); }
    
    .rule-block-header {
      position: absolute;
      top: -0.65rem;
      left: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--bg);
      padding: 0 0.35rem;
    }
    
    .rule-block-header .rule-marker {
      margin: 0;
    }
    
    .rule-block-header .spec-refs {
      margin: 0;
      font-size: 0.7rem;
    }
    
    .rule-block-content {
      margin-top: 0.25rem;
    }
    
    .rule-block-content p:first-child {
      margin-top: 0;
    }
    
    .rule-block-content p:last-child {
      margin-bottom: 0;
    }
    
    .spec-refs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin: 0.25rem 0 0.5rem 0;
      font-size: 0.75rem;
    }
    
    .spec-ref {
      font-family: 'IBM Plex Mono', monospace;
      text-decoration: none;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }
    
    .spec-ref:hover {
      border-color: var(--accent);
    }
    
    .spec-ref-icon {
      width: 0.9em;
      height: 0.9em;
      flex-shrink: 0;
    }
    
    .spec-ref-icon-impl {
      color: var(--green);
    }
    
    .spec-ref-icon-verify {
      color: var(--accent);
    }
    
    .spec-ref-impl {
      color: var(--green);
    }
    
    .spec-ref-verify {
      color: var(--accent);
    }
    
    /* Empty state */
    .empty-state {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--fg-muted);
      font-size: 0.9rem;
    }
    
    
    /* Custom dropdowns */
    .custom-dropdown {
      position: relative;
      display: inline-block;
    }
    .dropdown-selected {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.6rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      color: var(--fg);
      min-width: 90px;
    }
    .dropdown-selected:hover {
      background: var(--hover);
    }
    .dropdown-selected svg {
      width: 1rem;
      height: 1rem;
      flex-shrink: 0;
    }
    .dropdown-selected svg path {
      fill: currentColor;
    }
    .dropdown-selected .chevron {
      margin-left: auto;
      opacity: 0.5;
    }
    .dropdown-selected .chevron path {
      fill: none;
      stroke: currentColor;
    }
    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 4px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      min-width: 100%;
      display: none;
    }
    .custom-dropdown.open .dropdown-menu {
      display: block;
    }
    .dropdown-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      color: var(--fg-muted);
      white-space: nowrap;
    }
    .dropdown-option:first-child {
      border-radius: 5px 5px 0 0;
    }
    .dropdown-option:last-child {
      border-radius: 0 0 5px 5px;
    }
    .dropdown-option:hover {
      background: var(--hover);
    }
    .dropdown-option.active {
      background: var(--hover);
      color: var(--fg);
    }
    .dropdown-option svg {
      width: 1rem;
      height: 1rem;
      flex-shrink: 0;
    }
    .dropdown-option svg path {
      fill: currentColor;
    }
    
    /* Level dots */
    .level-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .level-dot-all { background: var(--fg-muted); }
    .level-dot-must { background: var(--red); }
    .level-dot-should { background: var(--yellow); }
    .level-dot-may { background: var(--accent); }
    
    /* File reference styling */
    .ref-line {
      white-space: nowrap;
      margin-bottom: 0.35rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    .ref-line:last-child {
      margin-bottom: 0;
    }
    .ref-icon {
      width: 1em;
      height: 1em;
      flex-shrink: 0;
      opacity: 0.7;
    }
    .ref-icon-impl { color: var(--green); }
    .ref-icon-verify { color: var(--accent); }
    .file-link {
      text-decoration: none;
      display: inline-flex;
    }
    .file-link:hover .file-name {
      text-decoration: underline;
    }
    .file-path {
      color: var(--fg-dim);
    }
    .file-name {
      color: var(--accent);
    }
    .file-line {
      color: var(--green);
    }
    

    
    /* Header controls */
    .header-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-left: auto;
    }
    
    /* Rule ID with icon */
    .rule-id-row {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    .rule-icon {
      width: 1em;
      height: 1em;
      color: var(--fg-dim);
      flex-shrink: 0;
    }
    
    /* Outline tree */
    .outline-tree {
      padding: 0.5rem;
    }
    
    .outline-item {
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--fg-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .outline-item:hover {
      background: var(--hover);
      color: var(--fg);
    }
    
    .outline-item.active {
      background: var(--accent-dim);
      color: var(--accent);
    }
    
    .outline-level-1 { padding-left: 0.5rem; font-weight: 500; }
    .outline-level-2 { padding-left: 1.25rem; }
    .outline-level-3 { padding-left: 2rem; }
    .outline-level-4 { padding-left: 2.75rem; font-size: 0.8rem; }
  </style>
</head>
<body>
  <div id="app"><div class="loading">Loading...</div></div>
  <script type="module">
    import { h, render, Fragment } from 'preact';
    import { useState, useEffect, useMemo, useCallback, useRef } from 'preact/hooks';
    import htm from 'htm';
    import { marked } from 'marked';
    import { highlight } from '@arborium/arborium';

    const html = htm.bind(h);
    
    // Cache for highlighted code
    const highlightCache = new Map();

    // ========================================================================
    // API
    // ========================================================================
    
    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    // ========================================================================
    // Routing
    // ========================================================================
    
    function parseRoute() {
      const path = window.location.pathname;
      const params = new URLSearchParams(window.location.search);
      
      // /sources or /sources/path/to/file.rs:123
      if (path === '/sources' || path.startsWith('/sources/')) {
        const rest = path.length > 9 ? path.slice(9) : ''; // Remove '/sources/'
        if (rest) {
          const colonIdx = rest.lastIndexOf(':');
          if (colonIdx !== -1) {
            const file = rest.slice(0, colonIdx);
            const line = parseInt(rest.slice(colonIdx + 1), 10);
            return { view: 'sources', file, line: isNaN(line) ? null : line };
          }
          return { view: 'sources', file: rest, line: null };
        }
        return { view: 'sources', file: null, line: null };
      }
      // /spec or /spec/rule.id
      if (path.startsWith('/spec')) {
        const rule = path.length > 5 ? path.slice(6) : params.get('rule');
        return { view: 'spec', rule };
      }
      // Default to forward
      return { 
        view: 'forward',
        filter: params.get('filter'), // 'impl' or 'verify' or null
      };
    }
    
    function buildUrl(view, params = {}) {
      if (view === 'sources') {
        const { file, line } = params;
        if (file) {
          return line ? `/sources/${file}:${line}` : `/sources/${file}`;
        }
        return '/sources';
      }
      if (view === 'spec') {
        const { rule } = params;
        return rule ? `/spec/${rule}` : '/spec';
      }
      // forward
      const searchParams = new URLSearchParams();
      if (params.filter) searchParams.set('filter', params.filter);
      const query = searchParams.toString();
      return `/forward${query ? '?' + query : ''}`;
    }
    
    function navigate(view, params = {}, replace = false) {
      const url = buildUrl(view, params);
      if (replace) {
        history.replaceState(null, '', url);
      } else {
        history.pushState(null, '', url);
      }
      window.dispatchEvent(new PopStateEvent('popstate'));
    }
    
    function useRouter() {
      const [route, setRoute] = useState(parseRoute);
      
      useEffect(() => {
        const handlePopState = () => setRoute(parseRoute());
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);
      
      return route;
    }

    // ========================================================================
    // Hooks
    // ========================================================================
    
    function useApi() {
      const [data, setData] = useState(null);
      const [error, setError] = useState(null);
      const [version, setVersion] = useState(null);

      const fetchData = useCallback(async () => {
        try {
          const [config, forward, reverse] = await Promise.all([
            fetchJson('/api/config'),
            fetchJson('/api/forward'),
            fetchJson('/api/reverse'),
          ]);
          setData({ config, forward, reverse });
          setError(null);
        } catch (e) {
          setError(e.message);
        }
      }, []);

      // Initial fetch
      useEffect(() => {
        fetchData();
      }, [fetchData]);

      // Poll for version changes and refetch if changed
      useEffect(() => {
        let active = true;
        let lastVersion = null;

        async function poll() {
          if (!active) return;
          try {
            const res = await fetchJson('/api/version');
            if (lastVersion !== null && res.version !== lastVersion) {
              console.log(`Version changed: ${lastVersion} -> ${res.version}, refetching...`);
              await fetchData();
            }
            lastVersion = res.version;
            setVersion(res.version);
          } catch (e) {
            console.warn('Version poll failed:', e);
          }
          if (active) setTimeout(poll, 500);
        }

        poll();
        return () => { active = false; };
      }, [fetchData]);

      return { data, error, version, refetch: fetchData };
    }

    function useFile(path) {
      const [file, setFile] = useState(null);
      
      useEffect(() => {
        if (!path) {
          setFile(null);
          return;
        }
        fetchJson('/api/file?path=' + encodeURIComponent(path))
          .then(setFile)
          .catch(e => {
            console.error('Failed to load file:', e);
            setFile(null);
          });
      }, [path]);

      return file;
    }

    function useSpec(name) {
      const [spec, setSpec] = useState(null);
      
      useEffect(() => {
        if (!name) {
          setSpec(null);
          return;
        }
        fetchJson('/api/spec?name=' + encodeURIComponent(name))
          .then(setSpec)
          .catch(e => {
            console.error('Failed to load spec:', e);
            setSpec(null);
          });
      }, [name]);

      return spec;
    }

    // ========================================================================
    // Utils
    // ========================================================================
    
    function buildFileTree(files) {
      const root = { name: '', children: {}, files: [], totalUnits: 0, coveredUnits: 0 };
      
      for (const file of files) {
        const parts = file.path.split('/');
        let current = root;
        
        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!current.children[part]) {
            current.children[part] = { name: part, children: {}, files: [], totalUnits: 0, coveredUnits: 0 };
          }
          current = current.children[part];
        }
        
        current.files.push({ ...file, name: parts[parts.length - 1] });
      }
      
      // Compute folder coverage recursively
      function computeCoverage(node) {
        let total = 0;
        let covered = 0;
        
        // Add files in this folder
        for (const f of node.files) {
          total += f.totalUnits || 0;
          covered += f.coveredUnits || 0;
        }
        
        // Add children folders
        for (const child of Object.values(node.children)) {
          computeCoverage(child);
          total += child.totalUnits;
          covered += child.coveredUnits;
        }
        
        node.totalUnits = total;
        node.coveredUnits = covered;
      }
      
      computeCoverage(root);
      return root;
    }

    function getCoverageBadge(covered, total) {
      if (total === 0) return { class: 'none', text: '-' };
      const pct = (covered / total) * 100;
      if (pct === 100) return { class: 'full', text: '100%' };
      if (pct >= 50) return { class: 'partial', text: Math.round(pct) + '%' };
      return { class: 'none', text: Math.round(pct) + '%' };
    }

    function getStatClass(pct) {
      if (pct >= 80) return 'good';
      if (pct >= 50) return 'warn';
      return 'bad';
    }

    // Render rule text with backticks -> <code> and RFC 2119 keywords highlighted
    function renderRuleText(text) {
      if (!text) return '';
      
      // Escape HTML first
      let result = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Process `code` (backticks)
      let inCode = false;
      let processed = '';
      for (const char of result) {
        if (char === '`') {
          if (inCode) {
            processed += '</code>';
            inCode = false;
          } else {
            processed += '<code>';
            inCode = true;
          }
        } else {
          processed += char;
        }
      }
      if (inCode) processed += '</code>';
      result = processed;
      
      // Wrap RFC 2119 keywords (order matters - longer phrases first)
      result = result
        .replace(/\bMUST NOT\b/g, '<kw-must-not>MUST NOT</kw-must-not>')
        .replace(/\bSHALL NOT\b/g, '<kw-shall-not>SHALL NOT</kw-shall-not>')
        .replace(/\bSHOULD NOT\b/g, '<kw-should-not>SHOULD NOT</kw-should-not>')
        .replace(/\bNOT RECOMMENDED\b/g, '<kw-not-recommended>NOT RECOMMENDED</kw-not-recommended>')
        .replace(/\bMUST\b/g, '<kw-must>MUST</kw-must>')
        .replace(/\bREQUIRED\b/g, '<kw-required>REQUIRED</kw-required>')
        .replace(/\bSHALL\b/g, '<kw-shall>SHALL</kw-shall>')
        .replace(/\bSHOULD\b/g, '<kw-should>SHOULD</kw-should>')
        .replace(/\bRECOMMENDED\b/g, '<kw-recommended>RECOMMENDED</kw-recommended>')
        .replace(/\bMAY\b/g, '<kw-may>MAY</kw-may>')
        .replace(/\bOPTIONAL\b/g, '<kw-optional>OPTIONAL</kw-optional>');
      
      return result;
    }

    // Highlight code using arborium (async, with caching)
    async function highlightCode(code, lang = 'rust') {
      const cacheKey = `${lang}:${code}`;
      if (highlightCache.has(cacheKey)) {
        return highlightCache.get(cacheKey);
      }
      try {
        const highlighted = await highlight(lang, code);
        highlightCache.set(cacheKey, highlighted);
        return highlighted;
      } catch (e) {
        console.warn('Highlight failed:', e);
        // Fallback: escape HTML
        return code
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }
    }
    
    // Split highlighted HTML into self-contained lines
    // Each line will have properly balanced open/close tags
    function splitHighlightedHtml(html) {
      // Use DOMParser for robust HTML parsing
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<div>${html}</div>`, 'text/html');
      const container = doc.body.firstChild;
      
      const lines = [];
      let currentLine = '';
      let openTags = []; // Stack of {tag, attrs}
      
      function processNode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          for (const char of text) {
            if (char === '\n') {
              // Close tags, push line, reopen tags
              for (let j = openTags.length - 1; j >= 0; j--) {
                currentLine += `</${openTags[j].tag}>`;
              }
              lines.push(currentLine);
              currentLine = '';
              for (const t of openTags) {
                currentLine += `<${t.tag}${t.attrs}>`;
              }
            } else {
              currentLine += char === '<' ? '&lt;' : char === '>' ? '&gt;' : char === '&' ? '&amp;' : char;
            }
          }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toLowerCase();
          let attrs = '';
          for (const attr of node.attributes) {
            attrs += ` ${attr.name}="${attr.value.replace(/"/g, '&quot;')}"`;
          }
          
          currentLine += `<${tag}${attrs}>`;
          openTags.push({ tag, attrs });
          
          for (const child of node.childNodes) {
            processNode(child);
          }
          
          openTags.pop();
          currentLine += `</${tag}>`;
        }
      }
      
      for (const child of container.childNodes) {
        processNode(child);
      }
      
      // Push final line if any content remains
      if (currentLine) {
        lines.push(currentLine);
      }
      
      return lines;
    }

    // Hook to highlight a file and split into lines
    function useHighlightedLines(content, lang = 'rust') {
      const [lines, setLines] = useState(null);
      
      useEffect(() => {
        if (!content) {
          setLines(null);
          return;
        }
        
        let cancelled = false;
        
        highlightCode(content, lang).then(highlighted => {
          if (cancelled) return;
          // arborium wraps in <pre><code>...</code></pre>, extract inner content
          const match = highlighted.match(/<pre[^>]*><code[^>]*>([\s\S]*)<\/code><\/pre>/);
          const inner = match ? match[1] : highlighted;
          // Split into self-contained lines with balanced tags
          setLines(splitHighlightedHtml(inner));
        });
        
        return () => { cancelled = true; };
      }, [content, lang]);
      
      return lines;
    }

    // ========================================================================
    // Components
    // ========================================================================
    
    function App() {
      const { data, error, version } = useApi();
      const route = useRouter();
      const [search, setSearch] = useState('');
      const [level, setLevel] = useState(() => localStorage.getItem('tracey-level') || 'all');
      const [editor, setEditor] = useState(() => localStorage.getItem('tracey-editor') || 'zed');
      const [scrollPositions, setScrollPositions] = useState({});

      // Persist level/editor to localStorage
      const handleLevelChange = useCallback((newLevel) => {
        setLevel(newLevel);
        localStorage.setItem('tracey-level', newLevel);
      }, []);

      const handleEditorChange = useCallback((newEditor) => {
        setEditor(newEditor);
        localStorage.setItem('tracey-editor', newEditor);
      }, []);

      if (error) return html`<div class="loading">Error: ${error}</div>`;
      if (!data) return html`<div class="loading">Loading...</div>`;

      const { config, forward, reverse } = data;
      const { view, file, rule, line, filter } = route;

      const handleViewChange = useCallback((newView) => {
        navigate(newView, {}, false);
      }, []);

      const handleSelectFile = useCallback((filePath, lineNum = null) => {
        navigate('sources', { file: filePath, line: lineNum }, false);
      }, []);

      const handleSelectRule = useCallback((ruleId) => {
        navigate('spec', { rule: ruleId }, false);
      }, []);
      
      const handleFilterChange = useCallback((newFilter) => {
        navigate('forward', { filter: newFilter }, false);
      }, []);

      return html`
        <div class="layout">
          <${Header} 
            view=${view} 
            onViewChange=${handleViewChange}
          />
          
          ${view === 'forward' && html`
            <${ForwardView} 
              data=${forward}
              config=${config}
              search=${search}
              onSearchChange=${setSearch}
              level=${level}
              onLevelChange=${handleLevelChange}
              editor=${editor}
              onEditorChange=${handleEditorChange}
              filter=${filter}
              onFilterChange=${handleFilterChange}
              onSelectRule=${handleSelectRule}
              onSelectFile=${handleSelectFile}
            />
          `}
          
          ${view === 'sources' && html`
            <${SourcesView} 
              data=${reverse}
              config=${config}
              search=${search}
              onSearchChange=${setSearch}
              editor=${editor}
              onEditorChange=${handleEditorChange}
              selectedFile=${file}
              selectedLine=${line}
              onSelectFile=${handleSelectFile}
              onSelectRule=${handleSelectRule}
            />
          `}
          
          ${view === 'spec' && html`
            <${SpecView}
              config=${config}
              forward=${forward}
              selectedRule=${rule}
              onSelectRule=${handleSelectRule}
              onSelectFile=${handleSelectFile}
              scrollPosition=${scrollPositions.spec || 0}
              onScrollChange=${(pos) => setScrollPositions(prev => ({ ...prev, spec: pos }))}
            />
          `}
        </div>
      `;
    }

    // Editor configurations
    const EDITORS = {
      zed: { name: 'Zed', urlTemplate: (path, line) => `zed://file/${path}:${line}` },
      vscode: { name: 'VS Code', urlTemplate: (path, line) => `vscode://file/${path}:${line}` },
      idea: { name: 'IntelliJ', urlTemplate: (path, line) => `idea://open?file=${path}&line=${line}` },
      sublime: { name: 'Sublime', urlTemplate: (path, line) => `subl://open?url=file://${path}&line=${line}` },
      vim: { name: 'Vim', urlTemplate: (path, line) => `mvim://open?url=file://${path}&line=${line}` },
      emacs: { name: 'Emacs', urlTemplate: (path, line) => `emacs://open?url=file://${path}&line=${line}` },
    };

    const LEVELS = {
      all: { name: 'All', dotClass: 'level-dot-all' },
      must: { name: 'MUST', dotClass: 'level-dot-must' },
      should: { name: 'SHOULD', dotClass: 'level-dot-should' },
      may: { name: 'MAY', dotClass: 'level-dot-may' },
    };

    // Editor icons (SVG paths)
    const EDITOR_ICONS = {
      zed: html`<svg viewBox="0 0 90 90" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.4375 5.625C6.8842 5.625 5.625 6.8842 5.625 8.4375V70.3125H0V8.4375C0 3.7776 3.7776 0 8.4375 0H83.7925C87.551 0 89.4333 4.5442 86.7756 7.20186L40.3642 53.6133H53.4375V47.8125H59.0625V55.0195C59.0625 57.3495 57.1737 59.2383 54.8438 59.2383H34.7392L25.0712 68.9062H68.9062V33.75H74.5312V68.9062C74.5312 72.0128 72.0128 74.5312 68.9062 74.5312H19.4462L9.60248 84.375H81.5625C83.1158 84.375 84.375 83.1158 84.375 81.5625V19.6875H90V81.5625C90 86.2224 86.2224 90 81.5625 90H6.20749C2.44898 90 0.566723 85.4558 3.22438 82.7981L49.46 36.5625H36.5625V42.1875H30.9375V35.1562C30.9375 32.8263 32.8263 30.9375 35.1562 30.9375H55.085L64.9288 21.0938H21.0938V56.25H15.4688V21.0938C15.4688 17.9871 17.9871 15.4688 21.0938 15.4688H70.5538L80.3975 5.625H8.4375Z"/></svg>`,
      vscode: html`<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M74.9 11L45.3 40.4L22.7 22.1L11 27.9V72.1L22.7 77.9L45.3 59.6L74.9 89L100 77.9V22.1L74.9 11ZM22.7 60.1V39.9L35.5 50L22.7 60.1ZM74.9 60.1L52.8 50L74.9 39.9V60.1Z"/></svg>`,
      idea: html`<svg viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg"><path d="M14 103h100V25H14v78zm8-70h12v62H22V33zm50 54H44v-8h28v8zm6-46h12v54H78V41z"/></svg>`,
      sublime: html`<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 3L3 9.25V11.5L21 17.75V15.25L8.25 11.5L21 7.75V3M3 12.25V14.5L21 20.75V18.25L8.25 14.5L3 12.25Z"/></svg>`,
      vim: html`<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2L3 7V17L12 22L21 17V7L12 2M12 4.5L18 8V16L12 19.5L6 16V8L12 4.5M12 7L8 9.5V14.5L12 17L16 14.5V9.5L12 7Z"/></svg>`,
      emacs: html`<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2M12 4C16.42 4 20 7.58 20 12C20 16.42 16.42 20 12 20C7.58 20 4 16.42 4 12C4 7.58 7.58 4 12 4M8 7V17H16V15H10V7H8Z"/></svg>`,
    };

    // Tab icons
    const TAB_ICONS = {
      specification: html`<svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg>`,
      coverage: html`<svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20V10"/><path d="M18 20V4"/><path d="M6 20v-4"/></svg>`,
      sources: html`<svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>`,
    };
    
    // Icons for impl/verify refs
    const ICON_IMPL = `<svg class="spec-ref-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 18l6-6-6-6"/><path d="M8 6l-6 6 6 6"/></svg>`;
    const ICON_VERIFY = `<svg class="spec-ref-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M9 12l2 2 4-4"/></svg>`;

    function Header({ view, onViewChange }) {
      const handleNavClick = (e, newView) => {
        e.preventDefault();
        onViewChange(newView);
      };

      return html`
        <header class="header">
          <div class="header-inner">
            <nav class="nav">
              <a 
                href="/spec"
                class="nav-tab ${view === 'spec' ? 'active' : ''}"
                onClick=${(e) => handleNavClick(e, 'spec')}
              >${TAB_ICONS.specification}<span>Specification</span></a>
              <a 
                href="/forward"
                class="nav-tab ${view === 'forward' ? 'active' : ''}"
                onClick=${(e) => handleNavClick(e, 'forward')}
              >${TAB_ICONS.coverage}<span>Coverage</span></a>
              <a 
                href="/sources"
                class="nav-tab ${view === 'sources' ? 'active' : ''}"
                onClick=${(e) => handleNavClick(e, 'sources')}
              >${TAB_ICONS.sources}<span>Sources</span></a>
            </nav>
            
            <a href="/forward" class="logo" onClick=${(e) => handleNavClick(e, 'forward')}>tracey</a>
          </div>
        </header>
      `;
    }

    // Helper to split file path into dir and filename
    function splitPath(filePath) {
      const lastSlash = filePath.lastIndexOf('/');
      if (lastSlash === -1) return { dir: '', name: filePath };
      return { dir: filePath.slice(0, lastSlash + 1), name: filePath.slice(lastSlash + 1) };
    }

    // File reference component with icon
    function FileRef({ file, line, type, editor, config, onSelectFile }) {
      const { dir, name } = splitPath(file);
      const fullPath = config?.projectRoot ? `${config.projectRoot}/${file}` : file;
      const editorUrl = EDITORS[editor]?.urlTemplate(fullPath, line) || '#';
      
      const iconImpl = html`<svg class="ref-icon ref-icon-impl" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 18l6-6-6-6"/><path d="M8 6l-6 6 6 6"/></svg>`;
      const iconVerify = html`<svg class="ref-icon ref-icon-verify" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M9 12l2 2 4-4"/></svg>`;
      
      return html`
        <div class="ref-line">
          ${type === 'impl' ? iconImpl : iconVerify}
          <a 
            class="file-link" 
            href=${editorUrl}
            onClick=${(e) => { e.preventDefault(); onSelectFile(file, line); }}
            title="Open in editor"
          >
            <span class="file-path">${dir}</span>
            <span class="file-name">${name}</span>
            <span class="file-line">:${line}</span>
          </a>
        </div>
      `;
    }

    function ForwardView({ data, config, search, onSearchChange, level, onLevelChange, editor, onEditorChange, filter, onFilterChange, onSelectRule, onSelectFile }) {
      const [levelOpen, setLevelOpen] = useState(false);
      const [editorOpen, setEditorOpen] = useState(false);
      
      // Close dropdowns when clicking outside
      useEffect(() => {
        const handleClick = (e) => {
          if (!e.target.closest('#level-dropdown')) setLevelOpen(false);
          if (!e.target.closest('#editor-dropdown')) setEditorOpen(false);
        };
        document.addEventListener('click', handleClick);
        return () => document.removeEventListener('click', handleClick);
      }, []);
      
      const allRules = useMemo(() => 
        data.specs.flatMap(s => s.rules.map(r => ({ ...r, spec: s.name }))),
        [data]
      );
      
      const filteredRules = useMemo(() => {
        let rules = allRules;
        
        // Filter by level
        if (level !== 'all') {
          rules = rules.filter(r => r.level?.toLowerCase() === level);
        }
        
        // Filter by coverage (impl or verify)
        if (filter === 'impl') {
          rules = rules.filter(r => r.implRefs.length === 0);
        } else if (filter === 'verify') {
          rules = rules.filter(r => r.verifyRefs.length === 0);
        }
        
        // Filter by search
        if (search) {
          const q = search.toLowerCase();
          rules = rules.filter(r => 
            r.id.toLowerCase().includes(q) ||
            (r.text && r.text.toLowerCase().includes(q))
          );
        }
        
        return rules;
      }, [allRules, search, level, filter]);

      const stats = useMemo(() => {
        // Stats are based on level-filtered rules (not coverage filter)
        let rules = allRules;
        if (level !== 'all') {
          rules = rules.filter(r => r.level?.toLowerCase() === level);
        }
        const total = rules.length;
        const impl = rules.filter(r => r.implRefs.length > 0).length;
        const verify = rules.filter(r => r.verifyRefs.length > 0).length;
        return {
          total,
          impl,
          verify,
          implPct: total ? (impl / total) * 100 : 0,
          verifyPct: total ? (verify / total) * 100 : 0,
        };
      }, [allRules, level]);

      // Markdown icon
      const mdIcon = html`<svg class="rule-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 3v4a1 1 0 0 0 1 1h4"/><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"/><path d="M9 15l2 2 4-4"/></svg>`;

      return html`
        <div class="stats-bar">
          <div class="stat">
            <span class="stat-label">Rules</span>
            <span class="stat-value">${stats.total}</span>
          </div>
          <div class="stat clickable" onClick=${() => onFilterChange(filter === 'impl' ? null : 'impl')}>
            <span class="stat-label">Impl Coverage ${filter === 'impl' ? '(filtered)' : ''}</span>
            <span class="stat-value ${getStatClass(stats.implPct)}">${stats.implPct.toFixed(1)}%</span>
          </div>
          <div class="stat clickable" onClick=${() => onFilterChange(filter === 'verify' ? null : 'verify')}>
            <span class="stat-label">Test Coverage ${filter === 'verify' ? '(filtered)' : ''}</span>
            <span class="stat-value ${getStatClass(stats.verifyPct)}">${stats.verifyPct.toFixed(1)}%</span>
          </div>
          
          <div class="search-box">
            <input
              type="text"
              class="search-input"
              placeholder="Search rules... (Ctrl+K)"
              value=${search}
              onInput=${(e) => onSearchChange(e.target.value)}
            />
          </div>
          
          <div class="stats-controls">
            <!-- Level dropdown -->
            <div class="custom-dropdown ${levelOpen ? 'open' : ''}" id="level-dropdown">
              <div class="dropdown-selected" onClick=${(e) => { e.stopPropagation(); setLevelOpen(!levelOpen); }}>
                <span class="level-dot ${LEVELS[level].dotClass}"></span>
                <span>${LEVELS[level].name}</span>
                <svg class="chevron" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
              </div>
              <div class="dropdown-menu">
                ${Object.entries(LEVELS).map(([key, cfg]) => html`
                  <div 
                    key=${key}
                    class="dropdown-option ${level === key ? 'active' : ''}" 
                    onClick=${() => { onLevelChange(key); setLevelOpen(false); }}
                  >
                    <span class="level-dot ${cfg.dotClass}"></span>
                    <span>${cfg.name}</span>
                  </div>
                `)}
              </div>
            </div>
            
            <!-- Editor dropdown -->
            <div class="custom-dropdown ${editorOpen ? 'open' : ''}" id="editor-dropdown">
              <div class="dropdown-selected" onClick=${(e) => { e.stopPropagation(); setEditorOpen(!editorOpen); }}>
                ${EDITOR_ICONS[editor]}
                <span>${EDITORS[editor].name}</span>
                <svg class="chevron" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
              </div>
              <div class="dropdown-menu">
                ${Object.entries(EDITORS).map(([key, cfg]) => html`
                  <div 
                    key=${key}
                    class="dropdown-option ${editor === key ? 'active' : ''}" 
                    onClick=${() => { onEditorChange(key); setEditorOpen(false); }}
                  >
                    ${EDITOR_ICONS[key]}
                    <span>${cfg.name}</span>
                  </div>
                `)}
              </div>
            </div>
          </div>
        </div>
        <div class="main">
          <div class="content">
            <div class="content-body">
              <table class="rules-table">
                <thead>
                  <tr>
                    <th style="width: 45%">Rule</th>
                    <th style="width: 55%">References</th>
                  </tr>
                </thead>
                <tbody>
                  ${filteredRules.map(rule => html`
                    <tr key=${rule.id} onClick=${() => onSelectRule(rule.id)} style="cursor: pointer;">
                      <td>
                        <div class="rule-id-row">
                          ${mdIcon}
                          <span class="rule-id">${rule.id}</span>
                        </div>
                        ${rule.text && html`<div class="rule-text" dangerouslySetInnerHTML=${{ __html: renderRuleText(rule.text) }} />`}
                      </td>
                      <td class="rule-refs" onClick=${(e) => e.stopPropagation()}>
                        ${rule.implRefs.length > 0 || rule.verifyRefs.length > 0
                          ? html`
                              ${rule.implRefs.map(r => html`
                                <${FileRef} 
                                  key=${'impl:' + r.file + ':' + r.line}
                                  file=${r.file} 
                                  line=${r.line} 
                                  type="impl"
                                  editor=${editor}
                                  config=${config}
                                  onSelectFile=${onSelectFile}
                                />
                              `)}
                              ${rule.verifyRefs.map(r => html`
                                <${FileRef} 
                                  key=${'verify:' + r.file + ':' + r.line}
                                  file=${r.file} 
                                  line=${r.line} 
                                  type="verify"
                                  editor=${editor}
                                  config=${config}
                                  onSelectFile=${onSelectFile}
                                />
                              `)}
                            `
                          : html`<span style="color: var(--fg-dim)"></span>`
                        }
                      </td>
                    </tr>
                  `)}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      `;
    }

    function SourcesView({ data, config, search, editor, onEditorChange, selectedFile, selectedLine, onSelectFile, onSelectRule }) {
      const fileTree = useMemo(() => buildFileTree(data.files), [data.files]);
      const file = useFile(selectedFile);

      const filteredFiles = useMemo(() => {
        if (!search) return data.files;
        const q = search.toLowerCase();
        return data.files.filter(f => f.path.toLowerCase().includes(q));
      }, [data.files, search]);

      const stats = {
        total: data.totalUnits,
        covered: data.coveredUnits,
        pct: data.totalUnits ? (data.coveredUnits / data.totalUnits) * 100 : 0,
      };

      return html`
        <div class="stats-bar">
          <div class="stat">
            <span class="stat-label">Code Units</span>
            <span class="stat-value">${stats.total}</span>
          </div>
          <div class="stat">
            <span class="stat-label">Spec Coverage</span>
            <span class="stat-value ${getStatClass(stats.pct)}">${stats.pct.toFixed(1)}%</span>
          </div>
          <div class="stat">
            <span class="stat-label">Covered</span>
            <span class="stat-value good">${stats.covered}</span>
          </div>
          <div class="stat">
            <span class="stat-label">Uncovered</span>
            <span class="stat-value ${stats.total - stats.covered > 0 ? 'bad' : 'good'}">${stats.total - stats.covered}</span>
          </div>
        </div>
        <div class="main">
          <div class="sidebar">
            <div class="sidebar-header">Files</div>
            <div class="sidebar-content">
              <${FileTree} 
                node=${fileTree} 
                selectedFile=${selectedFile}
                onSelectFile=${onSelectFile}
                search=${search}
              />
            </div>
          </div>
          <div class="content">
            ${file ? html`
              <div class="content-header">${file.path}</div>
              <div class="content-body">
                <${CodeView} file=${file} config=${config} editor=${editor} selectedLine=${selectedLine} onSelectRule=${onSelectRule} />
              </div>
            ` : html`
              <div class="empty-state">Select a file to view coverage</div>
            `}
          </div>
        </div>
      `;
    }

    function FileTree({ node, selectedFile, onSelectFile, depth = 0, search, parentPath = '' }) {
      // Check if selected file is in this subtree
      const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;
      const containsSelectedFile = selectedFile && selectedFile.startsWith(currentPath + '/');
      const hasSelectedFile = selectedFile && (containsSelectedFile || node.files.some(f => f.path === selectedFile));
      
      const [open, setOpen] = useState(depth < 2 || hasSelectedFile);
      
      // Auto-expand when selected file changes to be in this subtree
      useEffect(() => {
        if (hasSelectedFile && !open) {
          setOpen(true);
        }
      }, [selectedFile, hasSelectedFile]);
      
      const folders = Object.values(node.children).sort((a, b) => a.name.localeCompare(b.name));
      const files = node.files.sort((a, b) => a.name.localeCompare(b.name));

      // Filter if searching
      const matchesSearch = (path) => {
        if (!search) return true;
        return path.toLowerCase().includes(search.toLowerCase());
      };

      if (depth === 0) {
        return html`
          <div class="file-tree">
            ${folders.map(f => html`
              <${FileTree} 
                key=${f.name}
                node=${f} 
                selectedFile=${selectedFile}
                onSelectFile=${onSelectFile}
                depth=${depth + 1}
                search=${search}
                parentPath=""
              />
            `)}
            ${files.filter(f => matchesSearch(f.path)).map(f => html`
              <${FileTreeFile} 
                key=${f.path}
                file=${f}
                selected=${selectedFile === f.path}
                onClick=${() => onSelectFile(f.path)}
              />
            `)}
          </div>
        `;
      }

      const hasMatchingFiles = files.some(f => matchesSearch(f.path)) || 
        folders.some(f => Object.values(f.children).length > 0 || f.files.some(ff => matchesSearch(ff.path)));

      if (search && !hasMatchingFiles) return null;

      const folderBadge = getCoverageBadge(node.coveredUnits, node.totalUnits);

      return html`
        <div class="tree-folder ${open ? 'open' : ''}">
          <div class="tree-folder-header" onClick=${() => setOpen(!open)}>
            <div class="tree-folder-left">
              <svg class="tree-folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18l6-6-6-6"/>
              </svg>
              <span>${node.name}</span>
            </div>
            <span class="folder-badge ${folderBadge.class}">${folderBadge.text}</span>
          </div>
          <div class="tree-folder-children">
            ${folders.map(f => html`
              <${FileTree} 
                key=${f.name}
                node=${f} 
                selectedFile=${selectedFile}
                onSelectFile=${onSelectFile}
                depth=${depth + 1}
                search=${search}
                parentPath=${currentPath}
              />
            `)}
            ${files.filter(f => matchesSearch(f.path)).map(f => html`
              <${FileTreeFile} 
                key=${f.path}
                file=${f}
                selected=${selectedFile === f.path}
                onClick=${() => onSelectFile(f.path)}
              />
            `)}
          </div>
        </div>
      `;
    }

    function FileTreeFile({ file, selected, onClick }) {
      const badge = getCoverageBadge(file.coveredUnits, file.totalUnits);
      
      return html`
        <div 
          class="tree-file ${selected ? 'selected' : ''}"
          onClick=${onClick}
        >
          <span class="tree-file-name">${file.name}</span>
          <span class="tree-file-badge ${badge.class}">${badge.text}</span>
        </div>
      `;
    }

    function CodeView({ file, config, editor, selectedLine, onSelectRule }) {
      const rawLines = file.content.split('\n');
      const highlightedLines = useHighlightedLines(file.content, 'rust');
      const [popoverLine, setPopoverLine] = useState(null);
      const [highlightedLineNum, setHighlightedLineNum] = useState(null);
      const codeViewRef = useRef(null);
      
      // Build line annotations
      const lineAnnotations = useMemo(() => {
        const annotations = new Map();
        for (const unit of file.units) {
          for (let line = unit.startLine; line <= unit.endLine; line++) {
            if (!annotations.has(line)) {
              annotations.set(line, { units: [], ruleRefs: new Set() });
            }
            const anno = annotations.get(line);
            anno.units.push(unit);
            for (const ref of unit.ruleRefs) {
              anno.ruleRefs.add(ref);
            }
          }
        }
        return annotations;
      }, [file]);

      // Use highlighted lines if available, otherwise show raw (escaped)
      const displayLines = highlightedLines || rawLines.map(line => 
        line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
      );
      
      // Build editor URL for a line
      const getEditorUrl = (lineNum) => {
        const fullPath = config?.projectRoot ? `${config.projectRoot}/${file.path}` : file.path;
        return EDITORS[editor]?.urlTemplate(fullPath, lineNum) || '#';
      };
      
      // Scroll to selected line when it changes
      useEffect(() => {
        if (selectedLine && codeViewRef.current && displayLines) {
          // Use requestAnimationFrame to ensure DOM is rendered
          requestAnimationFrame(() => {
            const lineElement = codeViewRef.current?.querySelector(`[data-line="${selectedLine}"]`);
            if (lineElement) {
              const container = codeViewRef.current.closest('.content-body');
              if (container) {
                // Calculate position to leave ~5 lines above, plus extra for headers
                const lineHeight = lineElement.offsetHeight;
                const headerOffset = 120; // header + stats bar
                const targetScrollTop = lineElement.offsetTop - (lineHeight * 5) - headerOffset;
                container.scrollTo({ top: Math.max(0, targetScrollTop) });
              }
              // Highlight the line (permanent until navigation changes)
              setHighlightedLineNum(selectedLine);
            }
          });
        }
      }, [selectedLine, file.path, displayLines]);
      
      // Close popover when clicking outside
      useEffect(() => {
        const handleClick = (e) => {
          if (!e.target.closest('.line-popover') && !e.target.closest('.line-number')) {
            setPopoverLine(null);
          }
        };
        document.addEventListener('click', handleClick);
        return () => document.removeEventListener('click', handleClick);
      }, []);

      return html`
        <div class="code-view" ref=${codeViewRef}>
          ${displayLines.map((lineHtml, i) => {
            const lineNum = i + 1;
            const anno = lineAnnotations.get(lineNum);
            const covered = anno && anno.ruleRefs.size > 0;
            const inUnit = anno && anno.units.length > 0;
            const isHighlighted = highlightedLineNum === lineNum;
            
            return html`
              <div 
                key=${lineNum}
                data-line=${lineNum}
                class="code-line ${inUnit ? (covered ? 'covered' : 'uncovered') : ''} ${isHighlighted ? 'highlighted' : ''}"
              >
                <span 
                  class="line-number" 
                  onClick=${(e) => { e.stopPropagation(); setPopoverLine(popoverLine === lineNum ? null : lineNum); }}
                >
                  ${lineNum}
                  ${popoverLine === lineNum && html`
                    <div class="line-popover">
                      <a href=${getEditorUrl(lineNum)} class="popover-btn" title="Open in ${EDITORS[editor]?.name}">
                        ${EDITOR_ICONS[editor]}
                        <span>Open in ${EDITORS[editor]?.name}</span>
                      </a>
                    </div>
                  `}
                </span>
                <span 
                  class="line-content"
                  dangerouslySetInnerHTML=${{ __html: lineHtml || ' ' }}
                />
                ${anno && anno.ruleRefs.size > 0 && html`
                  <span class="line-annotations">
                    <span class="annotation-count" title=${[...anno.ruleRefs].join(', ')}>${anno.ruleRefs.size}</span>
                    <span class="annotation-badges">
                      ${[...anno.ruleRefs].map(ref => html`
                        <a 
                          key=${ref}
                          class="annotation-badge" 
                          href=${buildUrl('spec', { rule: ref })}
                          onClick=${(e) => { e.preventDefault(); onSelectRule(ref); }}
                        >${ref}</a>
                      `)}
                    </span>
                  </span>
                `}
              </div>
            `;
          })}
        </div>
      `;
    }

    function SpecView({ config, forward, selectedRule, onSelectRule, onSelectFile, scrollPosition, onScrollChange }) {
      const spec = useSpec(config.specs[0]?.name);
      const [activeHeading, setActiveHeading] = useState(null);
      const contentRef = useRef(null);
      const contentBodyRef = useRef(null);
      const initialScrollPosition = useRef(scrollPosition);
      
      // Build rule coverage map
      const ruleCoverage = useMemo(() => {
        const map = new Map();
        for (const s of forward.specs) {
          for (const r of s.rules) {
            const hasImpl = r.implRefs.length > 0;
            const hasVerify = r.verifyRefs.length > 0;
            map.set(r.id, { 
              rule: r,
              status: hasImpl && hasVerify ? 'covered' : hasImpl || hasVerify ? 'partial' : 'uncovered'
            });
          }
        }
        return map;
      }, [forward]);

      // Extract headings from markdown and generate slugs
      const headings = useMemo(() => {
        if (!spec) return [];
        const result = [];
        const lines = spec.content.split('\n');
        for (const line of lines) {
          const match = line.match(/^(#{1,4})\s+(.+)$/);
          if (match) {
            const level = match[1].length;
            const text = match[2].trim();
            const slug = text.toLowerCase().replace(/[^\w]+/g, '-').replace(/^-|-$/g, '');
            result.push({ level, text, slug });
          }
        }
        return result;
      }, [spec]);

      // Process markdown to inject rule markers and add IDs to headings
      const processedContent = useMemo(() => {
        if (!spec) return '';
        let content = spec.content;
        
        // Replace r[rule.id] with styled markers + reference links
        // Only match at start of file or after a blank line, at the beginning of a line
        content = content.replace(/(^|\n\n)r\[([^\]]+)\]/g, (match, prefix, ruleId) => {
          const coverage = ruleCoverage.get(ruleId);
          const status = coverage?.status || 'uncovered';
          const rule = coverage?.rule;
          
          // Build reference tags with icons (same as Coverage tab)
          const iconImpl = `<svg class="spec-ref-icon spec-ref-icon-impl" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 18l6-6-6-6"/><path d="M8 6l-6 6 6 6"/></svg>`;
          const iconVerify = `<svg class="spec-ref-icon spec-ref-icon-verify" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M9 12l2 2 4-4"/></svg>`;
          
          // Helper to get just filename from path
          const getFileName = (path) => path.split('/').pop();
          
          let refHtml = '';
          if (rule) {
            const allRefs = [];
            if (rule.implRefs && rule.implRefs.length > 0) {
              rule.implRefs.forEach(r => {
                allRefs.push(`<a class="spec-ref spec-ref-impl" href="/tree/${r.file}:${r.line}" data-file="${r.file}" data-line="${r.line}" title="${r.file}:${r.line}">${iconImpl}${getFileName(r.file)}:${r.line}</a>`);
              });
            }
            if (rule.verifyRefs && rule.verifyRefs.length > 0) {
              rule.verifyRefs.forEach(r => {
                allRefs.push(`<a class="spec-ref spec-ref-verify" href="/tree/${r.file}:${r.line}" data-file="${r.file}" data-line="${r.line}" title="${r.file}:${r.line}">${iconVerify}${getFileName(r.file)}:${r.line}</a>`);
              });
            }
            if (allRefs.length > 0) {
              refHtml = allRefs.join('');
            }
          }
          
          const icon = `<svg class="rule-marker-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 3v4a1 1 0 0 0 1 1h4"/><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"/><path d="M9 15l2 2 4-4"/></svg>`;
          
          // Use special markers that we'll process after markdown parsing
          return `${prefix}<!--RULE_START:${ruleId}:${status}--><a class="rule-marker ${status}" href="/spec/${ruleId}" data-rule="${ruleId}">${icon}${ruleId}</a>${refHtml ? `<div class="spec-refs">${refHtml}</div>` : ''}<!--RULE_CONTENT_START-->`;
        });
        
        let html = marked.parse(content);
        
        // Add IDs to headings
        headings.forEach(h => {
          // Match the heading tag and add id attribute
          const headingRegex = new RegExp(`(<h${h.level}>)(${h.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(</h${h.level}>)`, 'i');
          html = html.replace(headingRegex, `<h${h.level} id="${h.slug}" data-slug="${h.slug}">$2$3`);
        });
        
        // Wrap rule blocks: find RULE_START marker, capture until next RULE_START or heading
        html = html.replace(/<!--RULE_START:([^:]+):([^-]+)-->([\s\S]*?)<!--RULE_CONTENT_START-->([\s\S]*?)(?=<!--RULE_START|<h[1-6]|$)/g, 
          (match, ruleId, status, header, content) => {
            // Clean up paragraph wrapping - the content is usually wrapped in <p> tags
            return `<div class="rule-block rule-block-${status}"><div class="rule-block-header">${header}</div><div class="rule-block-content">${content.trim()}</div></div>`;
          }
        );
        
        return html;
      }, [spec, ruleCoverage, headings]);

      // Set up intersection observer for headings
      useEffect(() => {
        if (!contentRef.current || !contentBodyRef.current || headings.length === 0) return;
        
        // Small delay to ensure DOM is ready
        const timeoutId = setTimeout(() => {
          const headingElements = contentRef.current.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');
          if (headingElements.length === 0) return;
          
          const observer = new IntersectionObserver(
            (entries) => {
              // Track which headings are visible
              const visibleHeadings = [];
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  visibleHeadings.push({
                    id: entry.target.id,
                    top: entry.boundingClientRect.top
                  });
                }
              });
              
              // Set the topmost visible heading as active
              if (visibleHeadings.length > 0) {
                visibleHeadings.sort((a, b) => a.top - b.top);
                setActiveHeading(visibleHeadings[0].id);
              }
            },
            {
              root: contentBodyRef.current,
              rootMargin: '-5% 0px -70% 0px',
              threshold: 0
            }
          );
          
          headingElements.forEach(el => observer.observe(el));
          
          // Set initial active heading
          if (headings.length > 0) {
            setActiveHeading(headings[0].slug);
          }
          
          return () => observer.disconnect();
        }, 100);
        
        return () => clearTimeout(timeoutId);
      }, [processedContent, headings]);

      // Track scroll position changes
      useEffect(() => {
        if (!contentBodyRef.current) return;
        
        const handleScroll = () => {
          if (onScrollChange) {
            onScrollChange(contentBodyRef.current.scrollTop);
          }
        };
        
        contentBodyRef.current.addEventListener('scroll', handleScroll, { passive: true });
        return () => contentBodyRef.current?.removeEventListener('scroll', handleScroll);
      }, [onScrollChange]);

      const scrollToHeading = useCallback((slug) => {
        if (!contentRef.current || !contentBodyRef.current) return;
        const el = contentRef.current.querySelector(`[id="${slug}"]`);
        if (el) {
          const targetScrollTop = el.offsetTop - 100;
          contentBodyRef.current.scrollTo({ top: Math.max(0, targetScrollTop) });
          setActiveHeading(slug);
        }
      }, []);
      
      // Handle clicks on headings, rule markers, and spec refs in the markdown
      useEffect(() => {
        if (!contentRef.current) return;
        
        const handleClick = (e) => {
          // Handle heading clicks
          const heading = e.target.closest('h1[id], h2[id], h3[id], h4[id]');
          if (heading) {
            const slug = heading.id;
            const url = `${window.location.origin}${window.location.pathname}#${slug}`;
            navigator.clipboard?.writeText(url);
            return;
          }
          
          // Handle rule marker clicks
          const ruleMarker = e.target.closest('a.rule-marker[data-rule]');
          if (ruleMarker) {
            e.preventDefault();
            const ruleId = ruleMarker.dataset.rule;
            onSelectRule(ruleId);
            return;
          }
          
          // Handle spec ref clicks
          const specRef = e.target.closest('a.spec-ref');
          if (specRef) {
            e.preventDefault();
            const file = specRef.dataset.file;
            const line = parseInt(specRef.dataset.line, 10);
            onSelectFile(file, line);
            return;
          }
        };
        
        contentRef.current.addEventListener('click', handleClick);
        return () => contentRef.current?.removeEventListener('click', handleClick);
      }, [processedContent, onSelectRule, onSelectFile]);
      
      // Scroll to selected rule, or restore scroll position
      useEffect(() => {
        if (!processedContent) return;
        
        // Use requestAnimationFrame to ensure DOM is updated after render
        let cancelled = false;
        requestAnimationFrame(() => {
          if (cancelled) return;
          // Double RAF to ensure layout is complete
          requestAnimationFrame(() => {
            if (cancelled || !contentRef.current || !contentBodyRef.current) return;
            
            if (selectedRule) {
              // Navigate to specific rule
              const ruleEl = contentRef.current.querySelector(`[data-rule="${selectedRule}"]`);
              if (ruleEl) {
                // Use getBoundingClientRect relative to the scroll container
                const containerRect = contentBodyRef.current.getBoundingClientRect();
                const ruleRect = ruleEl.getBoundingClientRect();
                const currentScroll = contentBodyRef.current.scrollTop;
                const targetScrollTop = currentScroll + (ruleRect.top - containerRect.top) - 150;
                contentBodyRef.current.scrollTo({ top: Math.max(0, targetScrollTop) });
                
                // Add highlight class
                ruleEl.classList.add('rule-marker-highlighted');
                
                // Remove highlight after animation
                setTimeout(() => {
                  ruleEl.classList.remove('rule-marker-highlighted');
                }, 3000);
              }
            } else if (initialScrollPosition.current > 0) {
              // Restore previous scroll position (only on initial mount)
              contentBodyRef.current.scrollTo({ top: initialScrollPosition.current });
              initialScrollPosition.current = 0; // Clear so we don't restore again
            }
          });
        });
        
        return () => { cancelled = true; };
      }, [selectedRule, processedContent]);

      if (!spec) {
        return html`
          <div class="main">
            <div class="empty-state">Loading spec...</div>
          </div>
        `;
      }

      return html`
        <div class="main">
          <div class="sidebar">
            <div class="sidebar-header">Outline</div>
            <div class="sidebar-content">
              <div class="outline-tree">
                ${headings.map(h => html`
                  <div 
                    key=${h.slug}
                    class="outline-item outline-level-${h.level} ${activeHeading === h.slug ? 'active' : ''}"
                    onClick=${() => scrollToHeading(h.slug)}
                  >
                    ${h.text}
                  </div>
                `)}
              </div>
            </div>
          </div>
          <div class="content">
            <div class="content-header">
              ${spec.sourceFile || spec.name}
            </div>
            <div class="content-body" ref=${contentBodyRef}>
              <div 
                class="markdown"
                ref=${contentRef}
                dangerouslySetInnerHTML=${{ __html: processedContent }}
              />
            </div>
          </div>
        </div>
      `;
    }

    // ========================================================================
    // Mount
    // ========================================================================
    
    render(html`<${App} />`, document.getElementById('app'));

    // Global keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        document.querySelector('.search-input')?.focus();
      }
    });
  </script>
</body>
</html>
